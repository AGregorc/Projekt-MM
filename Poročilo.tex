\documentclass{article}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{color} 
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{blkarray, bigstrut}
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  language=Octave,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\graphicspath{ {images/} }
\begin{document}
\pagenumbering{gobble} 
\begin{titlepage}
\author{Domen Gašperlin\\Rok Grmek\\Jakob Gaberc Artenjak\\Anže Gregorc\and Matemetično modeliranje, Fakulteta za računalništvo in informatiko}
\title{\textbf{1. Projekt\\Iskanje po zbirki dokumentov}}
\date{April, 2017}

\maketitle

\end{titlepage}

\pagenumbering{arabic}  
\section{Opis problema}
Namen projekta je izdelati iskalnik relevantnih dokumentov po ključnih besedah z metodo\textit{ latentnega semantičnega indeksiranja} (LSI), saj so metode, ki izberejo le dokumente, ki vsebujejo natanko iskane besede, precej nenatačne. Ljudje namreč uporabljamo veliko sopomenk, ki jih preproste metode ne povežejo. Metoda LSI zgradi model, ki združuje več besed v pojme in zato najde tudi dokumente, ki so relevantni, pa ne vsebujejo iskalne besede.

Izdelati je potrebno program, ki bo v dani zbirki za dane ključne besede poiskal najbolj relevantne dokumente.

\section{Naloge}
\subsection{Iz zbirke dokumentov zgradite matriko A povezav med besedami in dokumenti.}

Matrika A:
\begin{equation*}
  \mathbf{A}=
  \begin{blockarray}{*{5}{c} l}
    \begin{block}{*{5}{>{$\footnotesize}c<{$}} l}
      doc1 & doc2 &  &  docD & \\
    \end{block}
    \begin{block}{[*{5}{c}]>{$\footnotesize}l<{$}}
      a_{11}  & a_{12} & \dots           & a_{1D}       & \bigstrut[t]& beseda1 \\
       a_{11} & a_{12} &                    & \bigstrut[t] &                   &   beseda2 \\
      \vdots   &             & \ddots         &                    &                   &   \vdots  \\
      a_{B1} &              &  \bigstrut[t] & a_{BD}       &                   &  besedaB \\
    \end{block}
  \end{blockarray}
\end{equation*}

 Vsak dokument  ima v matriki svoj stolpec, vsaka beseda pa svojo vrstico. Element a\textsubscript{ij} pa je frekvenca i-te besede v j-tem dokumentu.\\*

Postopek gradnje:
\begin{lstlisting}
  number_of_docs = length(file_names);  # shranimo stevilo vseh dokumentov
  all_words = []; # inicializacija polja, ki bo vsebovala vse besede
  num_of_words_in_docs = zeros(1, number_of_docs); # vektor, ki za vsak dokument hrani stevilo vseh besed
  for i = 1:number_of_docs # sprehodimo se po vseh dokumentih
     # preberemo i-ti dokument
    doc = textread([path_to_docs, filesep, file_names{i}], '%s');
    # vse besede spremenimo na samo alfa numericne znake in v male crke
    for j = 1:length(doc)
      doc{j} = lower(doc{j}(isalnum(doc{j})));
    end
    # dodamo besede i-tega dokumenta v polje vseh besed
    all_words = [all_words; doc]; 
    # dodamo stevilo vseh besed v i-tem dokumentu
    num_of_words_in_docs(i) = length(doc); 
  end

\end{lstlisting}
Ko imamo zgrajeno polje vseh besed, moramo odstraniti podvojene besede in s tem ustvarimo polje, ki bo služilo kot stolpec v matriki A.
\begin{lstlisting}
[unique_words, ~, numbers] = unique(all_words);
\end{lstlisting}

In sedaj imamo vse pripravljeno za gradnjo matrike A:

\begin{lstlisting}
  all_possible_numbers = (1:length(unique_words))';   # vektor od 1 do st vseh unikatnih besed

# matrika A dimenzije (st. vseh unikatnih besed) x (st. vseh dokumentov) 
  A = zeros(length(unique_words), number_of_docs);
  doc_end = 0;

  # sprehodimo se po vseh dokumentih
  for i = 1:number_of_docs
    # hranita stevilo, pri kateri se zacnejo in koncajo besede i-tega dokumenta v polju vseh besed 
    doc_start = doc_end + 1; 
    doc_end = doc_start + num_of_words_in_docs(i) - 1;

    # dodamo frekvence i-tega dokumenta v matriko A
    A(:, i) = histc(numbers(doc_start:doc_end, 1), all_possible_numbers);
  end
\end{lstlisting}

\subsection{ }











\end{document}